# Динамическое программирование


## Цель работы

получение практических навыков применения методов динамического программирования.


## Продолжительность и сроки сдачи

Продолжительность работы: - 4 часа.

Мягкий дедлайн (10 баллов): 08.12.2025

Жесткий дедлайн (5 баллов): 15.12.2025


## Краткие теоретические сведения

**Динамическое программирование (ДП)** — это метод решения сложных задач путём разбиения их на более простые **подзадачи**. Ключевая идея заключается в **повторном использовании решений** уже решённых подзадач для избежания избыточных вычислений.

ДП применяется для задач, которые обладают двумя важными свойствами:

1.  **Перекрывающиеся подзадачи (Overlapping subproblems)**
    *   Одна и та же подзадача многократно возникает в процессе решения.
    *   *Пример:* Вычисление чисел Фибоначчи, где `F(n) = F(n-1) + F(n-2)`.

2.  **Оптимальная подструктура (Optimal substructure)**
    *   Оптимальное решение всей задачи можно построить из оптимальных решений её подзадач.
    *   *Пример:* Задача о кратчайшем пути в графе.

Существует два основных подхода:

1.  **Нисходящее ДП (Top-down)**
    *   **Принцип:** Рекурсивное решение с **мемоизацией** (кэшированием результатов).
    *   **Преимущества:** Интуитивно понятный, записывается как рекурсия.
    *   **Недостатки:** Накладные расходы на рекурсивные вызовы, риск переполнения стека.

2.  **Восходящее ДП (Bottom-up)**
    *   **Принцип:** Итеративное заполнение таблицы решений, начиная с простейших подзадач.
    *   **Преимущества:** Эффективно по памяти и времени, нет накладных расходов на рекурсию.
    *   **Недостатки:** Менее интуитивно понятный, требует определения порядка вычислений.

### Ключевые шаги построения решения ДП

1.  **Определение состояния (`dp[...]`)**
    *   *Что означает состояние?* Обычно — параметры, однозначно определяющие подзадачу.
    *   *Пример:* `dp[i][j]` — стоимость оптимального пути до клетки `(i, j)`.

2.  **Формулировка базовых случаев**
    *   *Что это?* Решения для smallest подзадач, которые известны заранее.
    *   *Пример:* Для чисел Фибоначчи: `dp[0] = 0`, `dp[1] = 1`.

3.  **Вывод рекуррентного соотношения**
    *   *Что это?* Правило, по которому решение текущей подзадачи выражается через решения уже решённых подзадач.
    *   *Пример:* Для задачи о рюкзаке: `dp[i][w] = max( dp[i-1][w], cost[i] + dp[i-1][w - weight[i]] )`.

4.  **Определение порядка вычислений**
    *   *Зачем?* Чтобы при вычислении `dp[i][j]` все необходимые значения были уже вычислены.

5.  **Восстановление ответа**
    *   *Зачем?* Часто требуется найти не только оптимальное значение, но и способ его достижения.
    *   *Как?* Обычно с помощью обратного хода по таблице решений.

### Классические задачи, решаемые ДП

*   **Числа Фибоначчи:** `F(n) = F(n-1) + F(n-2)`
*   **Задача о рюкзаке:** Выбор предметов с максимальной стоимостью и ограничением по весу.
*   **Наибольшая общая подпоследовательность (LCS):** Поиск общей подпоследовательности двух строк максимальной длины.
*   **Наибольшая возрастающая подпоследовательность (LIS):** Поиск самой длинной возрастающей подпоследовательности в массиве.
*   **Размен монет:** Найти минимальное количество монет для составления суммы.
*   **Редакционное расстояние (Левенштейна):** Минимальное число операций для превращения одной строки в другую.
*   **Умножение матриц:** Поиск оптимального порядка умножения матриц для минимизации операций.

### Оценка сложности

*   **Временная сложность:** Обычно определяется как `(количество подзадач) * (время решения одной подзадачи)`.
    *   *Пример:* Для задачи о рюкзаке с `n` предметами и вместимостью `W`: количество состояний = `n * W`, время на одно состояние = `O(1)`. Итоговая сложность: **O(n·W)**.
*   **Пространственная сложность:** Определяется размером таблицы `dp`. Часто можно оптимизировать, храня только необходимые данные (например, только предыдущую строку).

### Отличие от других методов

*   **От жадных алгоритмов:** ДП рассматривает все варианты и находит гарантированно оптимальное решение, а не локально оптимальный выбор.
*   **От полного перебора:** ДП избегает повторных вычислений за счёт запоминания результатов, что drastically сокращает время работы.

**Вывод:** Динамическое программирование — мощный инструмент для решения оптимизационных задач, позволяющий за счёт грамотного разбиения на подзадачи и избегания избыточных вычислений находить точные решения за полиномиальное время.


### Задания 

Реализовать все не реализованные алгоримтмы в лекции 14. 


### Методика и порядок выполнения работы

Для успешного выполнения и ащиты лабораторной работ, необходимо выполнить следующие этапы:

1. изучить теоретический материал по теме лабораторной работы (лекции, учебники);
2. написать программу для каждого задания;
3. оформить отчет по лабораторной работе;
4. защитить лабораторную работу.


### Содержание отчета и его форма

Отчет по лабораторной работе должен содержать:

1. Номер и название лабораторной работы; цель и задачи лабораторной работы.

2.  Словесная постановка задачи.
    В этом подразделе проводится полное описание задачи.
    Описывается суть задачи, анализ входящих в нее переменных, возможные ограничения, анализ условий
    при которых задача имеет решение (не имеет решения), анализ ожидаемых результатов;

3.  Листинг программного кода с комментариями, показывающие порядок выполнения лабораторной работы, и результаты, полученные в ходе её выполнения.


### Контрольные вопросы

1.  Дайте определение динамическому программированию (ДП). В чём его основная идея?
2.  Сформулируйте принцип оптимальности Беллмана. Почему он является основой ДП?
3.  В чём ключевое отличие динамического программирования от жадных алгоритмов и полного перебора?
4.  Что такое "перекрывающиеся подзадачи"? Приведите пример задачи, где они возникают.
5.  Что такое "оптимальная подструктура"? Почему это свойство необходимо для применения ДП?
6.  В чём разница между нисходящим (мемоизация, рекурсия с кешированием) и восходячным (табуляция, итеративное заполнение таблицы) подходами в ДП?
7.  Какие преимущества и недостатки у нисходящего подхода?
8.  Какие преимущества и недостатки у восходящего подхода?
9.  Что такое мемоизация? Как она помогает избежать повторных вычислений?
10. Как выбирается размерность и структура таблицы ДП? От чего зависит количество измерений?
11. Опишите задачу о нахождении n-го числа Фибоначчи. Как её решить с помощью ДП?
12. Опишите задачу о самой длинной возрастающей подпоследовательности (НВП). Как строится решение методом ДП?
13. Опишите задачу о рюкзаке (непрерывную и целочисленную). В чём разница в подходах к их решению?
14. Опишите задачу о расстановке скобок при перемножении матриц. Как с помощью ДП найти оптимальный порядок умножения?
15. Опишите задачу о наибольшей общей подпоследовательности (LCS). Как строится решение методом ДП?
16. Как определить, можно ли решить задачу методом динамического программирования?
17. Опишите общий алгоритм построения решения ДП:
    *   Определение состояния
    *   Формулировка рекуррентного соотношения
    *   Выбор базовых случаев
    *   Порядок вычислений
    * *Восстановление ответа*
18. Почему важно уметь восстанавливать ответ, а не только находить оптимальное значение?
19. Как можно уменьшить потребление памяти в решениях ДП (например, хранение только двух последних строк)?
20. В чём особенность задач на ДП на деревьях? Как определяется состояние в таких задачах?
21. Как оценить временную и пространственную сложность решения ДП?
22. Приведите пример задачи, где ДП позволяет снизить сложность с экспоненциальной до полиномиальной.
23. Что такое "сжатие состояний" в ДП? Приведите пример.
24. В чём заключается метод разделяй и властвуй с оптимизацией (Knuth optimization) для задач ДП?
25. Для задачи о числах Фибоначчи:
    *   Напишите рекурсивное решение без оптимизации
    *   Напишите решение с мемоизацией
    *   Напишите итеративное решение
    *   Сравните их эффективность
26. Для задачи о рюкзаке:
    *   Сформулируйте состояние ДП
    *   Запишите рекуррентное соотношение
    *   Предложите способ восстановления набора предметов
27. Решите задачу о нахождении пути в матрице с минимальной суммой:
    *   Сформулируйте состояние ДП
    *   Запишите рекуррентное соотношение
    *   Определите порядок заполнения таблицы
28. Для задачи о редакционном расстоянии (расстоянии Левенштейна):
    *   Объясните смысл состояния `dp[i][j]`
    *   Запишите рекуррентное соотношение
    *   Объясните смысл операций вставки, удаления и замены
29. В чём отличие динамического программирования от метода разделяй и властвуй?
30. Приведите пример задачи, которую можно решить как жадным алгоритмом, так и ДП. В каком случае какой метод предпочтительнее?
31. Приведите 2-3 примера реальных задач, которые эффективно решаются методом динамического программирования.
32. Как ДП используется в алгоритмах обработки естественного языка?
33. Как ДП применяется в биоинформатике для сравнения последовательностей?
34. *Задача на подумать:* Можно ли решить задачу коммивояжёра (TSP) с помощью ДП? Если да, то какова будет сложность решения?


### Список литературы

1. Кнут, Д. Э. Искусство программирования: пер. с англ. / Д. Э. Кнут . - 3-е изд. - Москва : Вильямс, 2007. - Т. 1 : Основные алгоритмы, 2007. - 720 с. : ил.. - Прил.: с. 683-691. - Предм.-имен. указ.: с. 692-712. - ISBN 5-8459-0080-8.
2. Кнут, Д. Э. Искусство программирования / Д. Э. Кнут ; под общ. ред. Ю. В. Козаченко. - 2-е изд. - М. : Вильямс, 2009. - (Классический труд : Исправленное и дополненное издание). Т. 3 : Сортировка и поиск. - , 2009. - 823 с. : ил.. - Прил.: с. 794-803. - . - Предм.-имен. указ.: с. 804-822 - ISBN 978-5-8459-0082-1.
3. Кормен, Т. Алгоритмы: Построение и анализ / Т. Кормен, Ч. Лейхерсон, Р. Риверст. – М.: МЦМНО, 2002.
4. Давыдов, В. Г.  Программирование и основы алгоритмизации: учеб.
пособие для вузов / В. Г. Давыдов. - М. : Высш. шк., 2003. - 447 с. : ил - ISBN 5-06-
004432-7.
5. Ахо, А. Построение и анализ вычислительных алгоритмов / А. Ахо, Дж. Хопкрофт, Дж. Ульмен. – М.: Мир, 1989. – 369с.
6. Никлаус Вирт Алгоритмы и структуры данных. – Санкт-Петербург: «Невский диалект», 2001.
