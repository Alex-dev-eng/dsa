# Эмпирический анализ временной сложности алгоритмов


## Цель работы

Эмпирический анализ временной сложности алгоритмов.


## Продолжительность и сроки сдачи

Продолжительность работы: - 4 часа.

Мягкий дедлайн (10 баллов): 29.09.2025

Жесткий дедлайн (5 баллов): 06.10.2025


## Краткие теоретические сведения

Временная сложность – это характеристика алгоритма, призванная давать представление о количестве времени, требуемом для работы алгоритма на определенном объеме данных. 
Оценка временной сложности алгоритма [1, 2, 4] осуществляется путем подсчета количества элементарных операций (сложений, умножений и т.д.), выполняемых алгоритмом для заданного объема данных. 
При этом предполагается, что выполнение каждой элементарной операции требует фиксированного количества времени.
В связи с тем, что время работы алгоритма может быть различно для данных разного объема, временную сложность принято определять
с помощью функции $T$ , отражающей зависимость времени работы алгоритма $T(n)$ от объема $n$ входных данных. 
При этом особое внимание уделается асимптотическому поведению $T(n)$ при $n \to \infty$. 
При анализе асимптотического поведения $T(n)$ естественным образом учитываются только слагаемые самого высокого порядка, причем без внимания к их константным множителям. 
Поэтому чаще всего временную сложность $T(n)$ записывают в формате $O$-большое.
В таких терминах утверждение о том, что временная сложность некоторого алгоритма равна $O(t(n))$, где $t(n) > 0$ – некоторая функция, означает, что с увеличением объема $n$ входных данных время работы алгоритма будет асимптотически возрастать не быстрее, чем $C \cdot t(n)$ с некоторой фиксированной константой $C > 0$. 
Например, $O(n^2)$ – временная сложность алгоритма сортировки пузырьком элементов действительного вектора $v$ размерности $n$, а $O(n3)$ – временная сложность алгоритма обычного умножения двух матриц размера $n × n$. 
В [3] приводятся временные сложности многих стандартных алгоритмов.

Оценка временной сложности алгоритмов не всегда проста; для некоторых алгоритмов временные сложности по-прежнему неизвестны. 
(Это замечание, конечно, не касается алгоритмов, рассматриваемых в данной
лабораторной работе, – их временные сложности могут быть оценены [1, 2, 4].) 

Для того, чтобы все-таки получить представление о временной сложности алгоритма, можно применять эмпирический подход [1].
Он состоит в проведении серии замеров времени работы алгоритма при изменении объема входных данных. 
Например, для алгоритма, принимающего на вход векторы размерности $n$, можно замерять машинное время
его работы при $n$, скажем, от $1$ до $10^5$ с шагом $10$. 
При этом предполагается, что алгоритм запускается в одинаковых условиях, в частности, на одном и том же компьютере, не выполняющем каких-либо дополнительных вычислительных процессов, способных существенно повлиять на время работы рассматриваемого алгоритма. 
Наличие одинаковых условий при каждом замере принципиально важно для качества полученных результатов. 

Стоит отметить, что и при использовании одного и того же компьютера достичь этого не всегда удается – влияние на результат могут оказывать многочисленные факторы, в том числе фоновые процессы системы. 
Разумный компромисс в такой ситуации – усреднять замеры времени по нескольким запускам для одного и того же объема данных.
На рисунках 1 и 2 приведены примеры эмпирического исследования временной сложности алгоритма, реализующего функцию $f(v) = 1$, и алгоритма сортировки пузырьком элементов вектора $v$ при разной размерности входного вектора $v$. 
Легко видеть, что эмпирически полученные кривые могут допускать даже значительные отклонения от теоретических кривых, но в среднем вполне очевидно соответствие между экспериментом и теорией.


## Задания

Для $n$ от 1 до $10^5 \cdot N$ c шагом $100 \cdot N$, где $N = (20 - \text{номер студента в списке группе})$, произведите для пяти запусков замер среднего машинного времени исполнения программ, реализующих нижеуказанные алгоритмы и функции. 

Изобразите на графике полученные данные, отражающие зависимость среднего времени исполнения от $n$. 
Проведите теоретический анализ временной сложности рассматриваемых алгоритмов и сравните эмпирическую и теоретическую временные сложности.


### Задание 1

Сгенерируйте $n$-мерный случайный вектор $v = [v_1, v_2, ..., v_n]$ с
неотрицательными элементами. 

Для полученного вектора $v$ осуществите подсчет функций и реализацию алгоритмов:

| №  | Оценивание | Функция | Вариант | Примечание |
|:--|:----------:|:-------|:-------|:----------:|
| 1.1.  доступ к элементу по индексу           | 2 балла | $f_1(i) = v(i)$                            | 2, 4, 5, 7, 9, 11, 13, 15, 16, 18 ||
| 1.2. сумма элементов                         | 2 балла | $f_2(v) = \sum\limits_{k=1}^{n} {v_k}$     | 1, 3, 6, 8, 10, 12, 14, 17? 19||
| 1.3  произведение элементов                  | 2 балла | $f_3(v) = \prod\limits_{k=1}^{n} {v_k}$    | 1, 2, 5, 6, 7, 10, 11, 14, 15, 16? 19 ||
| 1.4. вычисление полинома методом Горнера [2] | 2 балла | $f_4(v) = v_1 + x (v_2 + x(v_3+ \ldots))$, | 2, 4, 6, 9, 10, 11, 13, 16, 17, 18| |
| 1.5. поиск максимума простым перебором       | 2 балла | $f_5(v) = \max(v)$                         | 1, 3, 4, 7, 8, 9, 12, 14, 16, 18 ||
| 1.6. поиск минимума простым перебором        | 2 балла | $f_6(v) = \min(v)$                         | 3, 5, 6, 8, 10, 13, 15, 17? 19 ||
| 1.7. среднее арифметическое                  | 2 балла | $f_7(v) = \cfrac{1}{n} \cdot \sum\limits_{k=1}^{n} {v_k}$   | 1, 2, 4, 9, 11, 12, 13, 14, 15, 16, 18 ||
| 1.8. среднее гармоническое                   | 2 балла | $f_8(v) = \cfrac{n}{\sum\limits_{k=1}^{n} {\frac{1}{v_k}}}  $ | 3, 5, 7, 8, 12, 14, 17? 19| |


### Задание 2

Сгенерируйте случайные матрицы $A$ и $B$ размером $n × n$ с неотрицательными элементами. 

Найдите обычное матричное произведение матриц $A$ и $B$.


## Методика и порядок выполнения работы

Для успешного выполнения и ащиты лабораторной работ, необходимо выполнить следующие этапы:

1. изучить теоретический материал по теме лабораторной работы (лекции, учебники);
2. написать программу для каждого задания;
3. оформить отчет по лабораторной работе;
4. защитить лабораторную работу.


## Содержание отчета и его форма

Отчет по лабораторной работе должен содержать:

1. Номер и название лабораторной работы; цель и задачи лабораторной работы.

2.  Словесная постановка задачи.
    В этом подразделе проводится полное описание задачи.
    Описывается суть задачи, анализ входящих в нее переменных, возможные ограничения, анализ условий
    при которых задача имеет решение (не имеет решения), анализ ожидаемых результатов;

3.  Листинг программного кода с комментариями, показывающие порядок выполнения лабораторной работы, и результаты, полученные в ходе её выполнения.

4. Выводы по лабораторной работе.


## Контрольные вопросы

1. Дайте определение вычислительной сложности алгоритма. Почему анализ сложности важен в программировании?

2. Что такое "время выполнения" и "пространство (память)" алгоритма? Приведите примеры, когда приходится жертвовать одним ради другого.

3. Что такое асимптотический анализ? Почему он используется вместо точного замера времени в наносекундах?

4.  Объясните нотацию "О-большое" (Big O notation). Что она характеризует в худшем, среднем или лучшем случае?

5.  Назовите и запишите в порядке увеличения сложности 5-7 самых распространенных классов сложности (например, O(1), O(log n), O(n), O(n log n), O(n²), O(2ⁿ)). Для каждого приведите пример алгоритма.

6. Определите асимптотическую сложность (Big O) для следующих фрагментов кода:
  - Простой цикл от 0 до n.
  - Два вложенных цикла от 0 до n.
  - Цикл, в котором счетчик удваивается на каждом шаге (i = i  2).
  - Цикл, в котором счетчик уменьшается вдвое на каждом шаге (i = i / 2).
  - Функция с двумя независимыми циклами друг за другом.
  - Рекурсивная функция, которая на каждом шаге вызывает себя дважды (например, наивное вычисление чисел Фибоначчи).

7. В чем разница между сложностью в худшем случае (worst-case), в среднем (average-case) и в лучшем случае (best-case)? Приведите пример алгоритма, где эти случаи сильно различаются (например, QuickSort).

8. Что такое пространственная сложность? Как оценить пространственную сложность рекурсивной функции?

9. Дан алгоритм со сложностью O(n³) и алгоритм со сложностью O(2ⁿ). При каких n второй алгоритм может быть предпочтительнее первого? Почему? (Подсказка: подумайте о реальных ограничениях на размер входных данных).

10. Какова временная сложность операций в следующих структурах данных?
  - Поиск элемента в неотсортированном массиве.
  - Поиск элемента в отсортированном массиве (бинарный поиск).
  - Вставка элемента в начало связного списка.
  - Вставка элемента в хеш-таблицу (в среднем и в худшем случае).
  - Поиск минимального элемента в двоичной куче (min-heap).

11. Сравните алгоритмы сортировки:
  - Сложность QuickSort в среднем и в худшем случае. От чего она зависит?
  - Почему MergeSort всегда имеет сложность O(n log n), но часто на практике проигрывает QuickSort?
  - В каких случаях сортировка вставками (Insertion Sort) будет эффективнее MergeSort?

12. Что такое "пространственно-временная дилемма" (time-memory tradeoff)? Приведите пример.

13. Что такое NP-полнота? Чем класс задач P отличается от NP?

14. Почему нахождение полиномиального решения для одной NP-полной задачи важно для всех остальных?

15. Как доказывают, что задача является NP-полной? Что такое "сведение по Карпу" (Karp reduction)?

16. Что такое омега-нотация (Ω) и тета-нотация (Θ)? Чем они отличаются от O-нотации? Приведите примеры.

17. Объясните, почему сложность алгоритма определяется по самому быстрорастущему слагаемому и почему константы отбрасываются. (Например, почему O(2n + 100n² + 5) — это O(n²)).

18. Всегда ли алгоритм со сложностью O(log n) быстрее алгоритма O(n)? Почему?

19. Проанализируйте сложность данного участка кода (можно предложить конкретный код).

20. У вас есть отсортированный массив чисел. Придумайте алгоритм поиска двух чисел, сумма которых равна заданному числу X.
  - Оцените временную и пространственную сложность вашего решения.
  - Можно ли решить задачу эффективнее, чем полным перебором (O(n²))?

21. Дан алгоритм. Улучшите его асимптотическую сложность хотя бы на один порядок. (Пример: замена полного перебора на алгоритм "два указателя" или использование хеш-таблицы для избежания вложенных циклов).


## Список литературы

1. Левитин, А.В. Алгоритмы: введение в разработку и анализ. М.: Из-
дательский дом Вильямс, 2006

2. Макконелл Дж. Анализ алгоритмов. Вводный курс. М.: Техносфера, 2002.

3. Big-O complexities of common algorithms used in Computer Science
https://blogs.longwin.com.tw/wordpress/201608-bigoposter.pdf

4. Cormen, T.H., Leiserson, C.E., Rivest, R.L., Stein, C. Introduction to Algorithms. Third Edition. The MIT Press, 2009.


## Примечания

Для замера времени работы функции и построения графиков, можно воспользоваться примером, приведенным здесь:
[./example/usage_time_example.md](./example/usage_time_example.md)