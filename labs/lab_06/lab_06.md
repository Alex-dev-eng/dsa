# Итеративные и рекурсивные алгоритмы


## Цель работы

Изучить рекурсивные алгоритмы и рекурсивные структуры данных; научиться проводить анализ итеративных и рекурсивных процедур; исследовать эффективность итеративных и  рекурсивных процедур при реализации на ПЭВМ.


## Продолжительность и сроки сдачи

Продолжительность работы: - 4 часа.

Мягкий дедлайн (10 баллов): 10.11.2025

Жесткий дедлайн (5 баллов): 17.11.2025


## Краткие теоретические сведения

**Итеративный алгоритм** — это алгоритм, который выполняет набор инструкций **многократно** с помощью циклических конструкций (например, `for`, `while`). Он явно управляет состоянием вычислений через переменные-счетчики и аккумуляторы.

**Рекурсивный алгоритм** — это алгоритм, который **вызывает сам себя** для решения более мелких подзадач того же типа. Для остановки процесса должен иметь **базис(ы) рекурсии** — условие, при котором возвращается конкретное значение без вызова.

### Структура рекурсивного алгоритма

Любой рекурсивный алгоритм состоит из двух обязательных частей:
1. **Базис рекурсии (terminating condition)** — простое случайное условие, при котором функция возвращает результат напрямую, не делая новых вызовов. Предотвращает бесконечную рекурсию.
2. **Рекурсивный шаг** — вызов функции с **упрощенным** или **уменьшенным** набором аргументов. Должен вести к достижению базиса.

**Пример (вычисление факториала):**
```python
def factorial(n):
    # Базис рекурсии
    if n == 0:
        return 1
    # Рекурсивный шаг
    else:
        return n * factorial(n - 1)
```

### Косвенная и прямая рекурсия

* **Прямая рекурсия:** Функция вызывает саму себя непосредственно.
* **Косвенная рекурсия:** Функция A вызывает функцию B, которая в свою очередь вызывает функцию A. Цикл вызовов может быть длиннее.

### Стек вызовов и использование памяти

* При каждом рекурсивном вызове в **стеке вызовов** (call stack) сохраняется состояние текущей функции (значения локальных переменных, адрес возврата).
* Глубина рекурсии ограничена размером стека. При ее превышении возникает ошибка **переполнение стека** (Stack Overflow).
* Итеративные алгоритмы обычно используют **постоянную** память (O(1)), в то время как рекурсивные могут использовать **линейную** (O(n)) или более память из-за стека.

### Преобразование рекурсии в итерацию и наоборот

* Любой рекурсивный алгоритм можно преобразовать в итеративный, и наоборот.
* Для преобразования рекурсии в итерацию часто используется **стек** для явного хранения состояния, которое в рекурсии сохраняется автоматически.
* **Хвостовая рекурсия** — особый случай, когда рекурсивный вызов является *последней* операцией в функции. Такую рекурсию компиляторы/интерпретаторы могут оптимизировать в итерацию для экономии памяти (оптимизация хвостового вызова, TCO).

### Сравнительная характеристика

| Критерий | Итеративный подход | Рекурсивный подход |
| :--- | :--- | :--- |
| **Читаемость** | Может быть менее читаем для рекурсивных по своей природе задач (деревья, графы). | Часто более лаконичен и интуитивно понятен, так как повторяет математическое определение. |
| **Производительность (память)** | Обычно **выше**. Не uses стек вызовов, использование памяти часто O(1). | Обычно **ниже**. Требует памяти под стек вызовов. Риск переполнения стека. |
| **Производительность (скорость)** | Выше из-за отсутствия накладных расходов на вызов функции. | Ниже из-за накладных расходов на организацию вызовов и возвратов. |
| **Простота реализации** | Проще для линейных процессов. | Проще для задач с древовидной структурой или которые naturally рекурсивны (обход директорий, синтаксический разбор). |

### Области применения

**Итерация:** Линейная обработка данных (массивы, списки), простые циклы, алгоритмы с явным управлением состоянием.

**Рекурсия:** 
* **Задачи, разбиваемые на подзадачи:** сортировка слиянием, быстрая сортировка, бинарный поиск.
* **Обход древовидных структур:** обход дерева каталогов файловой системы, синтаксический анализ (AST).
* **Комбинаторные задачи:** нахождение всех перестановок, сочетаний.
* **Динамическое программирование:** многие задачи ДП удобно записывать рекурсивно (с мемоизацией).

**Вывод:** Выбор между итерацией и рекурсией является компромиссом между эффективностью и ясностью кода. Рекурсия мощный инструмент для решения сложных задач, но требует осторожности из-за риска переполнения стека. Итерация часто более эффективна по памяти и должна выбираться для простых циклов или когда глубина вычислений может быть большой.


## Задания

**Задание 1.** (по вариантам)

1. Реализуйте рекурсивный алгоритм для нахождения биномиальных коэффициентов, пользуясь следующим определением
$$C_n^k = \cfrac{n!}{k!(n-k)!}$$

2. Реализуйте рекурсивный алгоритм для вычисления квадратного корня числа. В качестве исходных данных используйте тройку чисел $N$, $A$ и $E$, где $N$ - число, из которого требуется извлечь квадратный корень, $А$ - приближенное значение корня, $Е$ - допустимая ошибка результата.

3. Функция Аккермана определяется следующим образом:
$$A(0,y) = y+1;$$
$$A(x,0) = A(x-1,1);$$
$$A(x,y) = A(x-1,A(x,y-1)).$$
Здесь $x$ и $y$ – целые неотрицательные числа. Определим модулярную функцию Аккермана как $A \mod m$, где параметр $m$ - целое неотрицательное число. Реализуйте рекурсивный алгоритм построения таблицы значений этой функции.

4. Реализуйте рекурсивный алгоритм вычисления последовательности $n$ вложенных корней
$$ x(i) = \sqrt{m+\sqrt{m+\ldots+\sqrt{m}}}, \qquad m \geq 0, \qquad i = 1,2,\ldots, n$$

5. Реализуйте рекурсивный алгоритм вычисления суммы $n$ первых членов ряда
$$1 + \cfrac{x}{1!} + \cfrac{x^2}{2!} + \cfrac{x^3}{3!} + \cdots + \cfrac{x^{n-1}}{(n-1)!} + \cdots $$

6. Реализуйте рекурсивный алгоритм вычисления суммы $n$ первых членов ряда
$$x + \cfrac{x^3}{3!} + \cfrac{x^5}{2!} + \cfrac{x^7}{4!} + \cdots + \cfrac{x^{2n-1}}{n!} + \cdots $$

7. Реализуйте рекурсивный алгоритм, распечатывающий по одному разу в лексикографическом порядке все последовательности длины $N$, составленные из натуральных чисел $1, 2, \ldots, K$.

8. Реализуйте рекурсивный алгоритм подсчета $Q_{MN}$ - числа способов, с помощью которых можно представить целое число $М$ в виде суммы, каждое слагаемое которой не превосходит $N$. Воспользуйтесь следующим определением
$$ Q_{M,N} =  
\left\{
  \begin{array}{ll}
    1, & \text{если} M = 1, \text{при всех} N,\\
    1, & \text{если} N = 1, \text{при всех} M,\\
    Q_{M,M}, & \text{M < N}, \\
    1 + Q_{M,M-1}, & \text{M = N}, \\
     Q_{M,N-1} + Q_{M-N,N}, & \text{M > N}, \\
  \end{array}
\right.$$

9. Реализуйте рекурсивный алгоритм решения уравнений вида $F(x) = x$ методом простых итераций.

10. Реализуйте рекурсивный алгоритм перевода натурального числа из десятичной системы счисления в систему счисления с основанием $N$, $N \leq 10$.

11. Реализуйте алгоритм вычисления суммы с использованием рекурсии
$$ y(x,i) = \sin x + \sin(\sin x) + \ldots + \sin(\sin \ldots (\sin x)), \qquad i = 1,2,\ldots, n$$

12.  Задана строка $S$ из $N$ символов. Реализуйте рекурсивный алгоритм проверки, является ли симметричной часть строки, начинающаяся $i$-м и заканчивающаяся $j$-м ее элементом.

13. Реализуйте рекурсивный алгоритм, распечатывающий различные представления заданного натурального числа $N$ в виде суммы не менее двух натуральных слагаемых. Представления, отличающиеся лишь порядком слагаемых, различными не считаются.

14. Реализуйте рекурсивный алгоритм, распечатывающий все возрастающие последовательности длины $N$, элементами которых являются натуральные числа  $1, 2, \ldots, K$.

15. Реализуйте рекурсивный алгоритм, который определяет $N$ членов ряда Фибоначчи.

16. Реализуйте рекурсивный алгоритм, распечатывающий все перестановки натуральных чисел $1, 2, \ldots, N$. по одному разу. Перестановка - последовательность длины $N$, в которую каждое из этих чисел входит по одному разу.

17. Реализуйте рекурсивный алгоритм нахождения наибольшего общего делителя последовательности $N$ натуральных чисел.

18. Реализуйте рекурсивный алгоритм вычисления определителя заданной матрицы, пользуясь формулой разложения по первой строке:
$$ \det A = \sum \left( (-1)^{k+1} a_{1k} \det B_k \right)$$
где матрица $B_k$ получается из $А$ вычеркиванием первой строки и $k$-го столбца.

19.  Функция  $f(n)$ определена  для целых следующим образом:
$$ f(n) =  
\left\{
  \begin{array}{ll}
    1, & \text{если} n = 1,\\
    \sum\limits_{i=2}^n f(n \; div \; i), & \text{если} n \geq 2.\\
  \end{array}
\right.$$

20. Реализуйте алгоритм вычисления цепной дроби для произвольного значения $n \geq 0$ с помощью рекурсии

$$
\cfrac{1}
  {1 + \cfrac{1}{
     3 + \cfrac{1}{
       5 + \cfrac{1}{
         7 + \cfrac{1}{
           9 + \cfrac{1}{
             11 + \cdots
           }
         }  
       }
     }
  }
}
$$


### Задание 2

Реализуйте алгоритмы из задания 1 не используя рекурсию.


### Задание 3

Для каждого реализованного алгоритма:
- составьте блок-схему;

- оцените верхнюю границу размерности задачи, для которой при рекурсивной реализации не происходит переполнение стека вызовов;

- модернизируйте рекурсивную реализацию так, чтобы сохранялись промежуточные результаты вызова рекурсии (реализуйте подобный механизм вручную, а также, с помощью декоратора);

- сравните производительность реализованных алгоритмов (количество итераций (соответственно вызовов рекурсии) подбирайте исходя из условий задачи).


## Контрольные вопросы

1.  Дайте определение итеративного алгоритма. Приведите пример.
2.  Дайте определение рекурсивного алгоритма. Приведите пример.
3.  Назовите два обязательных элемента любой рекурсивной функции. Объясните их назначение.
4.  Что такое глубина рекурсии? Чем она ограничена?
5.  Что такое переполнение стека (Stack Overflow)? При каких условиях оно возникает?
6.  Сравните итеративный и рекурсивный подходы по следующим критериям:
    *   Читаемость кода
    *   Использование памяти (стек вызовов)
    *   Скорость выполнения
7.  Объясните, почему рекурсивные решения часто используют больше памяти, чем их итеративные аналоги.
8.  Для каких типов задач рекурсивный подход является более предпочтительным и естественным? Обоснуйте свой ответ.
9.  Для каких типов задач лучше подходит итеративный подход? Почему?
10. Что такое хвостовая рекурсия? Почему она является важной?
11. Опишите общий алгоритм преобразования простого рекурсивного алгоритма в итеративный.
12. Какую структуру данных часто используют для эмуляции рекурсии в итеративном коде? Объясните на примере.
13. Можно ли любую рекурсивную функцию преобразовать в итеративную? А наоборот?
14. Преобразуйте данный итеративный цикл (например, для вычисления суммы чисел) в рекурсивную функцию.
15. Преобразуйте данную рекурсивную функцию (например, для печати чисел от n до 1) в итеративный алгоритм.
16. Напишите рекурсивную и итеративную версии функции для вычисления n-го числа Фибоначчи.
17. Объясните, в чем заключается основная проблема наивного рекурсивного вычисления чисел Фибоначчи. Как ее можно решить?
18. Напишите рекурсивную функцию для вычисления факториала числа. Преобразуйте ее в итеративную.
19. Опишите рекурсивный алгоритм бинарного поиска в отсортированном массиве.
20. Опишите рекурсивный алгоритм для нахождения наибольшего общего делителя (НОД) двух чисел (алгоритм Евклида).
21. Пошагово протрассируйте выполнение данной рекурсивной функции для небольшого значения n (например, `f(3)`). Покажите состояние стека вызовов на каждом шаге.
    *Пример функции:*
    `python
    def f(n):
        if n <= 1:
            return n
        else:
            return f(n-1) + f(n-2)
    `
22. Сколько раз будет вызвана рекурсивная функция `f(4)` в приведенном выше примере? Нарисуйте дерево рекурсивных вызовов.
23. В чем заключается ключевое различие между прямой и косвенной (непрямой) рекурсией? Приведите пример косвенной рекурсии.
24. Что такое мемоизация? Как она может улучшить производительность рекурсивных алгоритмов? Приведите пример.
25. *Задача на рассуждение:* Почему обход дерева (например, бинарного дерева поиска) часто реализуют с помощью рекурсии, а не итерации?
26. *Задача на рассуждение:* Всегда ли рекурсия делает код более читаемым? Приведите пример, когда итерация может быть понятнее.
27. Объясните, как работает оптимизация хвостовой рекурсии (TCO) и почему она важна.
28. Что такое "неявный стек" и как он используется в итеративных алгоритмах обхода деревьев?


## Методика и порядок выполнения работы

Для успешного выполнения и ащиты лабораторной работ, необходимо выполнить следующие этапы:

1. изучить теоретический материал по теме лабораторной работы (лекции, учебники);
2. написать программу для каждого задания;
3. оформить отчет по лабораторной работе;
4. защитить лабораторную работу.


## Содержание отчета и его форма

Отчет по лабораторной работе должен содержать:

1. Номер и название лабораторной работы; цель и задачи лабораторной работы.

2.  Словесная постановка задачи.
    В этом подразделе проводится полное описание задачи.
    Описывается суть задачи, анализ входящих в нее переменных, возможные ограничения, анализ условий
    при которых задача имеет решение (не имеет решения), анализ ожидаемых результатов;

3.  Листинг программного кода с комментариями, показывающие порядок выполнения лабораторной работы, и результаты, полученные в ходе её выполнения.

4. Выводы по лабораторной работе.


## Список литературы

Вирт. Н. Алгоритмы и структуры данных: пер. с англ. / Н.Вирт. Изд. 2-е,
испр. – СПб.: Невский диалект, 2005. – 352 с.

Седжвик Р. Фундаментальные алгоритмы на C. Анализ/Структуры данных/Сортировка/Поиск = Algorithms in C. Fundamentals/Data Structures/Sorting/Searching. — СПб.: ДиаСофтЮП, 2003. — С. 672. — ISBN 5-93772-081-4.

Копец Д. Классические задачи Computer Science на языке Python. Питер, 2010, 256 с.


## Примечания

Блок-схемы алгоритмов необходимо реализовать в соответствии с примером, расположенным здесь: по 
[https://www.overleaf.com/learn/latex/LaTeX_Graphics_using_TikZ%3A_A_Tutorial_for_Beginners_(Part_3)%E2%80%94Creating_Flowcharts](https://www.overleaf.com/learn/latex/LaTeX_Graphics_using_TikZ%3A_A_Tutorial_for_Beginners_(Part_3)%E2%80%94Creating_Flowcharts)
