# Двоичные деревья поиска (Binary Search Tree)


### Цель работы

Изучение структуры данных «Двоичное дерево поиска», а также основных операций над ним.


### Продолжительность и сроки сдачи

Продолжительность работы: - 4 часа.

Мягкий дедлайн (10 баллов): 24.11.2025

Жесткий дедлайн (5 баллов): 01.12.2025


## Краткие теоретические сведения

Дерево — это совокупность элементов, называемых узлами (при этом один из них определен как корень), и отношений (родительский–дочерний), образующих иерархическую структуру узлов. Узлы могут являться величинами любого простого или структурированного типа, за исключением файлового. Узлы, которые не имеют ни одного последующего узла, называются листьями.

В двоичном (бинарном) дереве каждый узел может быть связан не более чем с двумя другими узлами. Рекурсивно двоичное дерево определяется так: двоичное дерево бывает либо пустым (не содержит ни одного узла), либо содержит узел, называемый корнем, а также два независимых поддерева — левое поддерево и правое поддерево.

Для обработки дерева достаточно знать адрес корневой вершины.

Высотой поддерева будем считать максимальную длину цепи $y_1, ...$, его вершин такую, что $y_{i+1}$ – потомок $y_i$ для всех i.
Высота пустого дерева равна нулю, высота дерева из одного корня – единице.

Степенью вершины в дереве называется количество дуг, которое из нее выходит.
Степень дерева равна максимальной степени вершины, входящей в дерево.
При этом листьями в дереве являются вершины, имеющие степень нуль.

Двоичное дерево поиска может быть либо пустым, либо оно обладает таким свойством, что корневой элемент имеет большее значение узла, чем любой элемент в левом поддереве, и меньшее или равное, чем элементы в правом поддереве.
Указанное свойство называется характеристическим свойством двоичного дерева
поиска и выполняется для любого узла такого дерева, включая корень. Важное
свойство такого дерева: все элементы его различны. Название двоичные деревья
поиска получили по той причине, что скорость поиска в них примерно такая же, что и в отсортированных массивах: $O(n) = C \cdot \log_2{n}$ (в худшем случае O(n) = n).

### Основные операции

Большинство операций над деревьями носят рекурсивный характер, поскольку дерево само по себе является рекурсивной структурой данных.

### Поиск элементов в дереве
Алгоритм поиска в двоичном дереве очень прост:

Начиная с корневой вершины для каждого текущего поддерева надо выполнить следующие шаги:
- сравнить ключ вершины с заданным значением x;
- если заданное значение меньше ключа вершины, перейти к левому поддереву, иначе перейти к правому поддереву.

Поиск прекращается при выполнении одного из двух условий:
- либо, если найден искомый элемент;
- либо, если надо продолжать поиск в пустом поддереве, что является признаком отсутствия искомого элемента.

### Добавление элемента в дерево

Алгоритм добавления включает следующие шаги:
- выделение памяти для новой вершины;
- формирование информационной составляющей;
- формирование двух пустых ссылочных полей на будущих потомков;
- формирование в родительской вершине левого или правого ссылочного поля – адреса новой вершины.

### Удаление элемента из дерева

Теперь рассмотрим удаление вершины из двоичного дерева.
По сравнению с добавлением удаление реализуется более сложным алгоритмом, поскольку добавляемая вершина всегда является терминальной, а удаляться может любая, в том числе и нетерминальная. При этом может возникать несколько различных
ситуаций.

Рассмотрим фрагмент двоичного с целыми ключами.

**Ситуация 1.** Удаляемая вершина не имеет ни одного потомка, т.е. является терминальной. Удаление реализуется очень легко: обнулением соответствующего указателя у родителя.

**Ситуация 2.** Удаляемая вершина имеет только одного потомка. В этом случае удаляемая вершина вместе со своим потомком и родителем образуют фрагмент линейного списка. Удаление реализуется простым изменением указателя у родительского элемента.

**Ситуация 3.** Пусть удаляемая вершина имеет двух потомков. Этот случай наиболее сложен, поскольку нельзя просто в родительской вершине изменить соответствующее ссылочное поле на адрес одного из потомков удаляемой вершины.
Это может нарушить структуру дерева поиска. Существует специальное правило для определения вершины, которая должна
заменить удаляемую. Это правило состоит из двух взаимоисключающих действий:
 - либо войти в левое поддерево удаляемой вершины и в этом поддереве спуститься как можно глубже, придерживаясь только правых потомков; это
позволяет найти в дереве ближайшую меньшую вершину;
 - либо войти в правое поддерево удаляемой вершины и спуститься в нем как можно глубже, придерживаясь только левых потомков; это позволяет найти ближайшую большую вершину.

### Обход дерева.

**Обход в прямом направлении**:
- обработать корневую вершину текущего поддерева;
- перейти к обработке левого поддерева таким же образом;
- обработать правое поддерево таким же образом.

**Симметричный обход**:
- рекурсивно обработать левое поддерево текущего поддерева;
- обработать вершину текущего поддерева;
- рекурсивно обработать правое поддерево.

**Обход в обратном направлении**:
- рекурсивно обработать левое поддерево текущего поддерева;
- рекурсивно обработать правое поддерево;
- затем – вершину текущего поддерева.


## Задания


### Задание 1

Реализовать программу, выполняющую стандартный набор операций над  двоичным деревом поиска:
- формирование бинарного дерева;
- обход (прямой, симметричный, обратный) бинарного дерева;
- удаление заданной вершины из бинарного дерева;
- поиск заданной вершины в бинарном дереве (по значению);
- печать бинарного дерева на экран;
- проверка пустоты бинарного дерева;
- определение высоты бинарного дерева.


Требования:
 - дерево должно быть реализовано в виде класса;
 - каждая операция должна быть реализована как метод класса;
 - добавлению/удалению должна предшествовать проверка возможности выполнения этих операций;


### Задание 2

Реализовать самобалансирующееся дерево (AVL-дерево для четных вариантов, красно-черное дерево для нечетных вариантов)


### Задание 3 (по вариантам)

1. Найти сумму элементов бинарного дерева.
2. Найти вершины, у которых количество потомков в левом поддереве не равно количеству потомков в правом поддереве.
3. Найти вершины, для которых высота левого поддерева не равна высоте правого поддерева.
4. Вернуть поддерево вершиной которого является максимальный элемент дерева
5. Найти максимальный элемент бинарного дерева.
6. Написать функцию, которая определяет, есть ли в бинарном дереве хотя бы два одинаковых элемента.
7. Написать функцию, определяющую количество отрицательных элементов бинарного дерева.
8. Написать функцию, которая определяет, является ли бинарное дерево симметричным.
9. Написать функцию, которая определяет, является ли бинарное дерево деревом поиска.
10. Вывести все листья дерева в порядке возрастания.
11. Пусть имеется бинарное дерево T. Сформировать два дерева из отрицательных и неотрицательных элементов дерева T.
12. Вывести все листья дерева поиска в порядке возрастания.
13. Найти последний номер из всех уровней бинарного дерева, на которых есть положительные элементы.
14. На каждом уровне бинарного дерева найти максимальный элемент.
15. На каждом уровне дерева найти количество внутренних вершин и количество листьев.
16. Найти суммы элементов всех нечетных уровней.
17. Найти произведения элементов всех четных уровней.
18. Объединить два бинарных дерева поиска
19. Пусть имеется бинарное дерево T. Сформировать два дерева из четных и нечетных элементов дерева T.
20. Написать функцию, определяющую количество элементов бинарного дерева кратных трем.
21. Найти произведение элементов бинарного дерева.
22. Найти среднее арифметическое элементов бинарного дерева.
23. На каждом уровне бинарного дерева найти минимальный элемент.
24. Вернуть поддерево вершиной которого является минимальный элемент дерева
25. Найти сумму элементов бинарного дерева кратных трем
26. Вернуть поддерево вершиной которого является максимальный элемент дерева
27. Найти медиану элементов бинарного дерева.


### Методика и порядок выполнения работы

Для успешного выполнения и ащиты лабораторной работ, необходимо выполнить следующие этапы:

1. изучить теоретический материал по теме лабораторной работы (лекции, учебники);
2. написать программу для каждого задания;
3. оформить отчет по лабораторной работе;
4. защитить лабораторную работу.


### Содержание отчета и его форма

Отчет по лабораторной работе должен содержать:

1. Номер и название лабораторной работы; цель и задачи лабораторной работы.

2.  Словесная постановка задачи.
    В этом подразделе проводится полное описание задачи.
    Описывается суть задачи, анализ входящих в нее переменных, возможные ограничения, анализ условий
    при которых задача имеет решение (не имеет решения), анализ ожидаемых результатов;

3.  Листинг программного кода с комментариями, показывающие порядок выполнения лабораторной работы, и результаты, полученные в ходе её выполнения.

4. Выводы по лабораторной работе.


### Контрольные вопросы

1.  Дайте определение двоичного дерева поиска (BST). Сформулируйте основное свойство BST.
2.  Какие основные операции поддерживаются BST? Перечислите их временную сложность в среднем и худшем случае.
3.  Что такое высота дерева? Что такое сбалансированное дерево?
4.  Чем BST принципиально отличается от двоичной кучи (min-heap/max-heap)?
5.  Что такое обход дерева? Перечислите основные виды обходов (in-order, pre-order, post-order, level-order) и объясните, в каком порядке они посещают узлы.
6.  Опишите алгоритм поиска элемента в BST.
7.  Опишите алгоритм вставки нового элемента в BST. Всегда ли новый элемент добавляется в лист?
8.  Опишите алгоритм удаления элемента из BST. Разберите три случая: удаление листа, удаление узла с одним потомком, удаление узла с двумя потомками.
9.  Что такое преемник (in-order successor) и предшественник (in-order predecessor) узла? Какова их роль в операции удаления?
10. Нарисуйте BST, которое получится после вставки элементов в заданном порядке (например, [5, 3, 7, 1, 4, 6, 8]).
11. Для чего используется in-order обход BST? Каков порядок элементов при таком обходе?
12. Для чего используется pre-order обход? В каких практических задачах он может быть полезен?
13. Для чего используется post-order обход? Приведите пример задачи, где он необходим.
14. Какой обход используется для поиска в ширину (BFS)? Опишите алгоритм его реализации с использованием очереди.
15. Напишите рекурсивную и итеративную реализацию in-order обхода.
16. Что такое вырожденное дерево? Как оно образуется и к какой временной сложности операций приводит?
17. Почему важно поддерживать дерево сбалансированным? Назовите способы балансировки BST.
18. Назовите сбалансированные BST (например, AVL-дерево, Красно-черное дерево). В чем их основное преимущество?
19. Объясните, какова временная сложность операций вставки, удаления и поиска в сбалансированном BST.
20. Что такое вращения (rotations) в AVL-дереве? Для чего они нужны?
21. Приведите 2-3 примера практических задач, для решения которых эффективно использовать BST.
22. Как с помощью BST можно реализовать ассоциативный массив (словарь)?
23. Как найти k-й наименьший элемент в BST?
24. Как найти наименьший общий предок (LCA) двух узлов в BST?
25. Как проверить, является ли двоичное дерево BST?
26. Сравните BST и хеш-таблицу по следующим критериям:
    *   Скорость поиска, вставки, удаления (в среднем и худшем случае)
    *   Память
    *   Поддержка упорядоченности данных
    *   Простота реализации
27. В каких ситуациях BST предпочтительнее хеш-таблицы?
28. В каких ситуациях хеш-таблица предпочтительнее BST?
29. Опишите структуру узла BST на выбранном языке программирования.
30. Дан фрагмент кода операции удаления. Объясните, что делает каждая часть кода.


### Список литературы

1. Кнут, Д. Э. Искусство программирования: пер. с англ. / Д. Э. Кнут . - 3-е изд. - Москва : Вильямс, 2007. - Т. 1 : Основные алгоритмы, 2007. - 720 с. : ил.. - Прил.: с. 683-691. - Предм.-имен. указ.: с. 692-712. - ISBN 5-8459-0080-8.
2. Кнут, Д. Э. Искусство программирования / Д. Э. Кнут ; под общ. ред. Ю. В. Козаченко. - 2-е изд. - М. : Вильямс, 2009. - (Классический труд : Исправленное и дополненное издание). Т. 3 : Сортировка и поиск. - , 2009. - 823 с. : ил.. - Прил.: с. 794-803. - . - Предм.-имен. указ.: с. 804-822 - ISBN 978-5-8459-0082-1.
3. Кормен, Т. Алгоритмы: Построение и анализ / Т. Кормен, Ч. Лейхерсон, Р. Риверст. – М.: МЦМНО, 2002.
4. Давыдов, В. Г.  Программирование и основы алгоритмизации: учеб.
пособие для вузов / В. Г. Давыдов. - М. : Высш. шк., 2003. - 447 с. : ил - ISBN 5-06-
004432-7.
5. Ахо, А. Построение и анализ вычислительных алгоритмов / А. Ахо, Дж. Хопкрофт, Дж. Ульмен. – М.: Мир, 1989. – 369с.
6. Никлаус Вирт Алгоритмы и структуры данных. – Санкт-Петербург: «Невский диалект», 2001.
