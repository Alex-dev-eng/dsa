# Хеш-функции и хеш-таблицы


### Цель работы

Изучение хеш-функций и хеш-таблиц, а также основных операций над ними.


### Продолжительность и сроки сдачи

Продолжительность работы: - 4 часа.

Мягкий дедлайн (10 баллов): 27.10.2025

Жесткий дедлайн (5 баллов): 10.11.2025


## Краткие теоретические сведения


### Хеш-таблицы

**Хеш-таблица** — это структура данных, предназначенная для реализации ассоциативного массива (отображения ключей в значения). Она позволяет выполнять операции добавления, удаления и поиска элементов в среднем за **O(1)** время.

**Основные компоненты:**

* **Ключ** — уникальный идентификатор, по которому происходит поиск данных.
* **Значение** — данные, связанные с ключом.
* **Хеш-функция** — функция, преобразующая ключ в индекс (хеш-код) для размещения в таблице.
* **Массив бакетов** — массив, где хранятся элементы. Каждая ячейка массива называется **бакетом** (bucket) или **слотом**.
* **Коэффициент нагрузки** (load factor) — отношение количества элементов в таблице к размеру массива (n / size). Важный параметр для эффективности.

### Хеш-функции

**Хеш-функция** — это функция, которая преобразует ключ произвольного размера и типа в целое число (индекс) фиксированного диапазона [0, size-1].

**Требования к хорошей хеш-функции:**

1.  **Детерминированность:** Один и тот же ключ всегда должен давать один и тот же хеш-код.
2.  **Равномерное распределение:** Ключи должны равномерно распределяться по всем индексам таблицы для минимизации коллизий.
3.  **Вычислительная эффективность:** Функция должна быстро вычисляться.

**Распространенные методы вычисления хеш-кодов:**

* **Для целых чисел:** часто используют взятие по модулю размера таблицы: `hash(key) = key % size`.
* **Для строк:** популярна полиномиальная хеш-функция (например, метод Горнера), чтобы учесть значение каждого символа.

### Коллизии и методы их разрешения

**Коллизия** — ситуация, когда два разных ключа имеют одинаковый хеш-код и претендуют на один и тот же бакет.

**Основные методы разрешения коллизий:**

**1. Метод цепочек (Separate Chaining)**

Каждый бакет представляет собой связный список (или другую структуру), в котором хранятся все элементы с одинаковым хеш-кодом.

**Операции:**
* **Вставка:** Вычисляется индекс. Элемент добавляется в начало или конец списка в данном бакете.
* **Поиск:** Вычисляется индекс. Производится линейный поиск по списку в бакете по ключу.
* **Удаление:** Аналогично поиску, после нахождения элемент удаляется из списка.

**Преимущества:** Простота реализации, эффективен при высокой нагрузке.

**Недостатки:** Требует дополнительной памяти на хранение указателей.

**2. Метод открытой адресации (Open Addressing)**

Все элементы хранятся непосредственно в массиве. При коллизии элемент помещается в другую свободную ячейку согласно выбранной стратегии.

**Стратегии поиска свободной ячейки:**
* **Линейное пробирование:** `index = (hash(key) + i) % size`, где i = 0, 1, 2, ...
* **Квадратичное пробирование:** `index = (hash(key) + i²) % size`
* **Двойное хеширование:** `index = (hash1(key) + i * hash2(key)) % size`

**Преимущества:** Не требует дополнительной памяти для указателей, лучше использует кэш процессора.

**Недостатки:** Более сложное удаление элементов, может возникнуть "кластеризация" (скопление элементов), сильная зависимость от коэффициента нагрузки.

### Сложность операций

Средняя сложность операций сильно зависит от коэффициента нагрузки α = n / size.

| Метод разрешения коллизий | В среднем (хорошая хеш-функция) | В худшем случае (все ключи в одном бакете) |
| :--- | :--- | :--- |
| **Метод цепочек** | **O(1)** для всех операций | **O(n)** (вырождается в линейный поиск по списку) |
| **Открытая адресация** | **O(1)** для всех операций | **O(n)** (необходимость проверки всех ячеек) |

**Важно:** Для поддержания эффективности необходимо **динамическое изменение размера** таблицы (рехеширование), когда коэффициент нагрузки превышает определенный порог (обычно 0.7-0.75).

### Сравнение методов разрешения коллизий

| Критерий | Метод цепочек | Открытая адресация |
| :--- | :--- | :--- |
| **Память** | Больше (указатели) | Меньше (только массив) |
| **Зависимость от нагрузки** | Менее критична | Сильно зависит (при α ~ 1 операции замедляются) |
| **Удаление элементов** | Простое | Сложное (требует маркировки удаленных элементов) |
| **Кластеризация** | Не подвержена | Подвержена (особенно линейное пробирование) |
| **Локализация данных** | Хуже (списки в памяти) | Лучше (данные в массиве) |

### Области применения

* Реализация ассоциативных массивов (`dict` в Python, `HashMap` в Java, `unordered_map` в C++).
* Базы данных (индексы).
* Кэширование.
* Поиск дубликатов.
* Подсчет частоты элементов.


## Задания

**1.** Реализовать хеш-таблицу на основе метода цепочек.

**2.** Реализовать хеш-таблицу на основе открытой адресации.

**3. Блокчейн** (2 балла)
В блокчейне хеш-функции используются для создания уникальных идентификаторов блоков и обеспечения целостности данных. Каждый блок содержит хеш предыдущего блока, что создает цепочку и делает систему устойчивой к изменениям.

**4. Проверка пересечения двух массивов**

Проверьте, пересекаются ли два массива (имеют ли они хотя бы один общий элемент).

**5. Проверка уникальности элементов в массиве**

Проверьте, содержатся ли в массиве только уникальные элементы.

**6. Нахождение пар с заданной суммой**

Дан массив чисел и целевое значение суммы. Необходимо найти все пары чисел, которые в сумме дают целевое значение.

**7. Задача на проверку анаграмм**

Даны две строки. Необходимо определить, являются ли они анаграммами (содержат одни и те же символы в одинаковом количестве).


**Требования**:

- Задачи 1-3
  - структуры данных должны быть реализованы в виде классов;
  - каждая операция должна быть реализована как метод класса.
- Задачи 4-7
  - Решения задач должны быть реализованы в виде функций;
  - Все алгоритмы должны иметь временную сложность O(n).


### Методика и порядок выполнения работы

Для успешного выполнения и ащиты лабораторной работ, необходимо выполнить следующие этапы:

1. изучить теоретический материал по теме лабораторной работы (лекции, учебники);
2. написать программу для каждого задания;
3. оформить отчет по лабораторной работе;
4. защитить лабораторную работу.


### Содержание отчета и его форма

Отчет по лабораторной работе должен содержать:

1. Номер и название лабораторной работы; цель и задачи лабораторной работы.

2.  Словесная постановка задачи.
    В этом подразделе проводится полное описание задачи.
    Описывается суть задачи, анализ входящих в нее переменных, возможные ограничения, анализ условий
    при которых задача имеет решение (не имеет решения), анализ ожидаемых результатов;

3.  Листинг программного кода с комментариями, показывающие порядок выполнения лабораторной работы, и результаты, полученные в ходе её выполнения.

4. Выводы по лабораторной работе.


### Контрольные вопросы

1.  Дайте определение хеш-таблицы. Какую основную задачу она решает?
2.  Что такое хеш-функция? Какую роль она играет в работе хеш-таблицы?
3.  Перечислите и объясните ключевые свойства хорошей хеш-функции.
4.  Что такое коллизия? Почему невозможно полностью избежать коллизий на практике?
5.  Что такое коэффициент нагрузки (load factor)? Как он влияет на производительность хеш-таблицы?
6.  Опишите принцип работы метода цепочек (separate chaining).
7.  Опишите принцип работы метода открытой адресации (open addressing). Чем он принципиально отличается от метода цепочек?
8.  Объясните разницу между линейным, квадратичным пробированием и двойным хешированием. Какой метод наиболее эффективен и почему?
9.  В чем заключаются основные преимущества и недостатки метода цепочек по сравнению с методом открытой адресации?
10. Почему при использовании открытой адресации простое удаление элемента может нарушить целостность таблицы? Как правильно реализовать удаление в этом случае?
11. Объясните, почему в среднем случае операции с хеш-таблицей (вставка, поиск, удаление) имеют сложность O(1).
12. Опишите худший случай для хеш-таблицы. При каких условиях он возникает и какова сложность операций в этом случае?
13. Что такое рехеширование (rehashing) и для чего оно необходимо?
14. Как обычно выбирается момент для выполнения рехеширования?
15. Опишите процесс рехеширования: какие шаги необходимо выполнить?
16. Какую структуру данных удобно использовать для реализации бакетов в методе цепочек? Обоснуйте свой выбор.
17. Напишите формулу для вычисления индекса в хеш-таблице с использованием операции взятия по модулю.
18. Почему для хеш-таблицы часто рекомендуется использовать размер, являющийся простым числом?
19. Объясните, как можно построить хеш-функцию для строки. Приведите пример простой, но эффективной хеш-функции для строк.
20. Какие проблемы могут возникнуть, если хеш-функция распределяет ключи неравномерно?
21. В каких ситуациях предпочтительнее использовать метод цепочек, а в каких — открытую адресацию?
22. Приведите 2-3 примера реальных задач, где хеш-таблицы являются оптимальным выбором для решения.
23. Чем хеш-таблица принципиально отличается от сбалансированного двоичного дерева поиска (например, красно-черного дерева)? В чем их преимущества и недостатки друг перед другом?
24. Может ли хеш-таблица хранить несколько одинаковых ключей? Если да, то как это реализовать? Если нет, то почему?
25. Дан набор ключей и хеш-функция `h(key) = key % 7`. Постройте хеш-таблицу размером 7 для этих ключей, используя:
    *   а) метод цепочек
    *   б) линейное пробирование
    *   в) квадратичное пробирование
    Ключи: 12, 5, 19, 7, 26, 14, 33
26. Объясните, как с помощью хеш-таблицы можно эффективно решить задачу поиска двух чисел в массиве, сумма которых равна заданному числу X.
27. Как с помощью хеш-таблицы можно найти первый повторяющийся элемент в массиве?
28. *Продвинутый вопрос:* Что такое "идеальное хеширование" и в каких случаях оно применяется?


### Список литературы

1. Кнут, Д. Э. Искусство программирования: пер. с англ. / Д. Э. Кнут . - 3-е изд. - Москва : Вильямс, 2007. - Т. 1 : Основные алгоритмы, 2007. - 720 с. : ил.. - Прил.: с. 683-691. - Предм.-имен. указ.: с. 692-712. - ISBN 5-8459-0080-8.
2. Кнут, Д. Э. Искусство программирования / Д. Э. Кнут ; под общ. ред. Ю. В. Козаченко. - 2-е изд. - М. : Вильямс, 2009. - (Классический труд : Исправленное и дополненное издание). Т. 3 : Сортировка и поиск. - , 2009. - 823 с. : ил.. - Прил.: с. 794-803. - . - Предм.-имен. указ.: с. 804-822 - ISBN 978-5-8459-0082-1.
3. Кормен, Т. Алгоритмы: Построение и анализ / Т. Кормен, Ч. Лейхерсон, Р. Риверст. – М.: МЦМНО, 2002.
4. Давыдов, В. Г.  Программирование и основы алгоритмизации: учеб.
пособие для вузов / В. Г. Давыдов. - М. : Высш. шк., 2003. - 447 с. : ил - ISBN 5-06-
004432-7.
5. Ахо, А. Построение и анализ вычислительных алгоритмов / А. Ахо, Дж. Хопкрофт, Дж. Ульмен. – М.: Мир, 1989. – 369с.
6. Никлаус Вирт Алгоритмы и структуры данных. – Санкт-Петербург: «Невский диалект», 2001.
