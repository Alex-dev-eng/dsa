# Линейные списки (Linked list)


### Цель работы

изучение структуры данных «Линейные списки», а также основных операций над ними.


### Продолжительность и сроки сдачи

Продолжительность работы: - 4 часа.

Мягкий дедлайн (10 баллов): 13.10.2025

Жесткий дедлайн (5 баллов): 20.10.2025


## Краткие теоретические сведения

### Понятие линейного списка

**Линейный список** — это структура данных, представляющая собой конечный, упорядоченный набор элементов, называемых узлами (нодами). Порядок элементов определяется не их физическим расположением в памяти, а explicit ссылочными связями между ними.

Основное преимущество списков перед массивами — **динамичность**: размер списка может легко изменяться во время выполнения программы без необходимости выделения непрерывной области памяти и копирования данных.

### Виды линейных списков

Наиболее распространёнными видами являются:

* **Односвязный список (Singly Linked List):** Каждый узел содержит данные и одну ссылку на следующий узел в последовательности. Проход по списку возможен только в одном направлении — от начала к концу.

* **Двусвязный список (Doubly Linked List):** Каждый узел содержит данные и две ссылки: на следующий и на предыдущий узел. Это позволяет обходить список в обоих направлениях, что упрощает некоторые операции (например, удаление предыдущего элемента), но требует больше памяти для хранения дополнительных ссылок.  

* **Кольцевой список (Circular Linked List):** Может быть односвязным или двусвязным. Отличие заключается в том, что ссылка последнего узла указывает не на `null` (или `None`), а на первый узел списка, образуя кольцо.  

### Базовые компоненты

* **Узел (Node):** Основной строительный блок списка. Обычно представляет собой структуру или объект, содержащий:
    *   `data` (данные) — полезная информация, хранимая в узле.
    *   `next` (следующий) — указатель/ссылка на следующий узел.
    *   `prev` (предыдущий) — указатель/ссылка на предыдущий узел (только для двусвязного списка).

* **Голова (Head):** Указатель/ссылка на первый узел списка. Является точкой входа для работы со списком.

* **Хвост (Tail):** Указатель/ссылка на последний узел списка. Часто хранится для ускорения операций добавления в конец.

### Операции над списками и их сложность

В таблице приведена асимптотическая сложность основных операций, где `n` — количество элементов в списке.

| Операция | Односвязный список | Двусвязный список (с `tail`) | Примечания |
| :--- | :---: | :---: | :--- |
| **Поиск** элемента | O(n) | O(n) | Требуется последовательный проход. |
| **Вставка** в начало | **O(1)** | **O(1)** | Не зависит от размера списка. |
| **Вставка** в конец | O(n) | **O(1)** | Односвязный требует прохода до конца. |
| **Вставка** после/до известного узла | **O(1)** | **O(1)** | Если указатель на узел уже известен. |
| **Удаление** из начала | **O(1)** | **O(1)** | Не зависит от размера списка. |
| **Удаление** из конца | O(n) | **O(1)** | Односвязный требует прохода до конца. |
| **Удаление** известного узла | O(n) | **O(1)** | В односвязном нужно найти предыдущий узел. |
| **Доступ** по индексу | O(n) | O(n) | Требуется последовательный проход. |

*Примечание: Сложность O(1) для операций вставки/удаления достигается только в том случае, если указатель на узел, рядом с которым происходит операция, уже известен.*

### Преимущества и недостатки

| Критерий | Списки | Массивы |
| :--- | :--- | :--- |
| **Размер** | **Динамический**, легко изменяется. | Статический (обычно) или требует дорогой операции динамического расширения (resize). |
| **Вставка/Удаление** в начало/середину | **Эффективно (O(1))**, если известен узел. | **Неэффективно (O(n))**, требует сдвига элементов. |
| **Доступ к элементу по индексу** | **Неэффективно (O(n))**, требуется последовательный проход. | **Эффективно (O(1))** по адресной арифметике. |
| **Память** | **Дополнительная память** на хранение указателей. | **Экономичнее**, хранят только данные в непрерывной области. |
| **Локализация данных** | **Низкая**, узлы разбросаны в памяти (кэш-промахи). | **Высокая**, данные лежат рядом (кэш-дружественность). |

**Вывод:** Списки идеальны для сценариев, где часто происходят операции добавления и удаления в произвольных местах, особенно если обход происходит последовательно и не требуется частый произвольный доступ. Массивы же предпочтительнее, когда важен быстрый доступ по индексу и известен или фиксирован размер данных.


## Задания

**1.** Последовательно реализовать 6 версий линейного односвязного списка.

**2.** Реализовать метод `reverse` для &laquo;переворота&raquo; линейного списка.

**3.** Реализовать метод `sort` для сортировки линейного списка на месте.

**4.** Реализовать индивидуальные задание.

**5.** Опционально: реализовать один из видов циклов, рассмотренных на лекции.


## Индивидуальные задания

**Задание 1.**

1. Написать функцию, которая по двум линейным спискам L1 и L2 формирует новый список L, состоящий из элементов, входящих в L1, но не входящих в L2.
2. Найти количество максимальных элементов списка действительных чисел.
3. Сформировать список целых чисел, вводимых пользователем, в том порядке, в котором вводятся эти числа, но без повторений элементов.
4. Пусть имеется список L1 действительных чисел. Записать в список L2 все элементы списка L1 в порядке возрастания их значений.
5. Написать функцию, которая оставляет в списке L только последние вхождения одинаковых элементов.
6. Написать функцию, которая в линейном списке из каждой группы подряд идущих одинаковых элементов оставляет только один.
7. Написать функцию, которая по двум линейным спискам L1 и L2 формирует новый список L, состоящий из элементов, входящих в оба списка.
8. Написать функцию, которая по списку L строит два новых списка: L1 – из положительных элементов и L2 – из отрицательных элементов списка L.
9. Имеется список целых чисел. Продублировать в нем все четные числа.
10. Определить, является ли список упорядоченным по возрастанию.
11. Имеется список целых чисел. Удалить из него все нечетные числа.
12. Написать функцию, которая оставляет в списке L только первые вхождения одинаковых элементов.
13. Пусть имеется список действительных чисел $a_1 → a_2 → \ldots  → a_n$. Сформировать новый список $b_1 → b_2 → \ldots → b_n$ такой же размерности по следующему правилу: элемент $b_k$ равен сумме элементов исходного списка с номерами от 1 до k.
14. Написать функцию, которая по двум данным линейным спискам формирует новый список, состоящий из элементов, одновременно входящих в оба данных списка.
15. Написать функцию, которая удаляет из списка элементы, входящие в него только один раз.
16. Определить количество различных элементов списка действительных чисел, если известно, что его элементы образуют возрастающую последовательность.
17. Имеется список целых чисел. Удалить из него все четные числа.
18. Имеется список целых чисел. Все нечетные числа в нем умножить на 2, все четные разделить на 2.
19. Определить, есть ли в списке действительных чисел элементы, превосходящие сумму всех элементов списка.
20. Написать функцию, которая удаляет из списка элементы, входящие в него только более двух раз.
21. Вычислите среднее арифметическое элементов непустого списка.
22. Пусть имеются два списка, элементы которых упорядочены по возрастанию. Сформировать новый список из элементов первого и второго списка, элементы которого будут упорядочены.
23. Пусть имеется список L. Удалить из него каждый третий элемент.
24. Пусть имеется список L1 действительных чисел. Сформировать новый список L2, состоящий элемнтов списка L1, которые являются простыми числами.
25. Даны два списка. Определите, совпадают ли множества их элементов.
26. Вычислите среднее арифметическое элементов непустого списка.
27. Пусть имеется список L1 действительных чисел. Записать в список L2 все элементы списка L1, делящиеся на 3 в порядке убывания.
28. Удалить из списка действительных чисел все минимальные элементы.
29. Вычислите среднее геометрическое элементов непустого списка.
30. Пусть имеется список целых чисел L. Добавьте после каждого третьего элемента новый элемент, равный сумме трех предыдущих.
31. Написать функцию, которая по списку L строит два новых списка: L1 – из четных и L2 – из нечетных элементов списка L.
32. Дан список целых чисел. Продублировать в нем все простые числа.
33. Написать функцию, которая по двум линейным спискам L1 и L2 формирует новый список L, состоящий из попарных произведений элементов L1 и L2. Длина формируемого списка ограничивается длиной меньшего из списков L1, L2.
34. Определение, сколько различных значений содержится в списке.
35. Удалить из списка действительных чисел все максимальные элементы.
36. Определить, образуют ли элементы списка действительных чисел геометрическую прогрессию.
37. Пусть имеется список целых чисел L. Обменяйте местами максимальный и минимальный элемент списка.


## Методика и порядок выполнения работы

Для успешного выполнения и ащиты лабораторной работ, необходимо выполнить следующие этапы:

1. изучить теоретический материал по теме лабораторной работы (лекции, учебники);
2. написать программу для каждого задания;
3. оформить отчет по лабораторной работе;
4. защитить лабораторную работу.


## Содержание отчета и его форма

Отчет по лабораторной работе должен содержать:

1. Номер и название лабораторной работы; цель и задачи лабораторной работы.

2.  Словесная постановка задачи.
    В этом подразделе проводится полное описание задачи.
    Описывается суть задачи, анализ входящих в нее переменных, возможные ограничения, анализ условий
    при которых задача имеет решение (не имеет решения), анализ ожидаемых результатов;

3.  Листинг программного кода с комментариями, показывающие порядок выполнения лабораторной работы, и результаты, полученные в ходе её выполнения.

4. Выводы по лабораторной работе.


## Контрольные вопросы

1.  Дайте определение линейного списка. Чем его организация принципиально отличается от массива?
2.  Что такое «узел» (node)? Из каких основных полей он состоит в односвязном и двусвязном списках?
3.  Что такое «голова» (head) списка и какова её роль?
4.  Для чего в реализации списка может храниться указатель на «хвост» (tail)?
5.  Перечислите основные виды линейных списков (по типу связности).
6.  Опишите алгоритм добавления нового узла **в начало** односвязного списка. Почему эта операция выполняется за время O(1)?
7.  Опишите алгоритм добавления нового узла **в конец** односвязного списка. Почему в базовой реализации (без `tail`) эта операция имеет сложность O(n)?
8.  Как происходит удаление узла из односвязного списка? Почему для удаления узла, как правило, необходимо знать указатель на предыдущий элемент?
9.  В чём ключевое преимущество двусвязного списка перед односвязным при удалении произвольного узла? Опишите алгоритм удаления, если дан указатель непосредственно на удаляемый узел.
10. Что такое «кольцевой/циклический список»? Какие особенности необходимо учитывать при его обходе и обработке?
11. Заполните таблицу асимптотической сложности основных операций (укажите O(1), O(n) и т.д.):
    | Операция | Односвязный список (без tail) | Односвязный список (с tail) | Двусвязный список (с tail) |
    | :--- | :---: | :---: | :---: |
    | Вставка в начало | | | |
    | Вставка в конец | | | |
    | Удаление из начала | | | |
    | Удаление из конца | | | |
    | Поиск элемента по значению | | | |
    | Вставка после известного узла | | | |
    | Удаление известного узла | | | |
    | Доступ к элементу по индексу | | | |

12. Объясните, почему доступ к элементу по индексу в списке имеет сложность O(n), а в массиве — O(1).
13. Объясните, почему вставка в начало списка всегда выполняется за O(1), а вставка в конец в односвязном списке без `tail` — за O(n).
14. В каких ситуациях использование списка предпочтительнее использования массива (и наоборот)? Перечислите 2-3 преимущества и недостатка каждой структуры.
15. Приведите примеры задач, где эффективнее всего использовать именно связный список. Обоснуйте свой выбор.
16. Почему двусвязные списки часто используются для реализации более сложных структур данных, таких как очереди (deque) или хеш-таблицы с методом цепочек?
17. Что такое «виртуальная» или «фиктивная» нода (dummy node)? Как её использование может упростить код работы со списком (например, избежать отдельной обработки случая с пустым списком)?
18. Дан фрагмент кода, реализующий операцию со списком. Найдите ошибку или проанализируйте, что делает этот код.
    *Пример: вставка узла, удаление, обход и т.д.*
19. Опишите алгоритм реверсирования (разворота) односвязного списка. Можно ли выполнить эту операцию без выделения дополнительной памяти?
20. Как с помощью двух указателей («черепахи» и «зайца») определить, содержит ли связный список цикл (замкнутость)? Опишите алгоритм.
21. Как найти средний элемент односвязного списка за один проход?
22. В чем заключается проблема и как её избежать при удалении узла из односвязного списка, если дан указатель только на этот узел (и нет доступа к предыдущему)? Предложите решение.


### Список литературы

1. Кнут, Д. Э. Искусство программирования: пер. с англ. / Д. Э. Кнут . - 3-е изд. - Москва : Вильямс, 2007. - Т. 1 : Основные алгоритмы, 2007. - 720 с. : ил.. - Прил.: с. 683-691. - Предм.-имен. указ.: с. 692-712. - ISBN 5-8459-0080-8.
2. Кнут, Д. Э. Искусство программирования / Д. Э. Кнут ; под общ. ред. Ю. В. Козаченко. - 2-е изд. - М. : Вильямс, 2009. - (Классический труд : Исправленное и дополненное издание). Т. 3 : Сортировка и поиск. - , 2009. - 823 с. : ил.. - Прил.: с. 794-803. - . - Предм.-имен. указ.: с. 804-822 - ISBN 978-5-8459-0082-1.
3. Кормен, Т. Алгоритмы: Построение и анализ / Т. Кормен, Ч. Лейхерсон, Р. Риверст. – М.: МЦМНО, 2002.
4. Давыдов, В. Г.  Программирование и основы алгоритмизации: учеб.
пособие для вузов / В. Г. Давыдов. - М. : Высш. шк., 2003. - 447 с. : ил - ISBN 5-06-
004432-7.
5. Ахо, А. Построение и анализ вычислительных алгоритмов / А. Ахо, Дж. Хопкрофт, Дж. Ульмен. – М.: Мир, 1989. – 369с.
6. Никлаус Вирт Алгоритмы и структуры данных. – Санкт-Петербург: «Невский диалект», 2001.
